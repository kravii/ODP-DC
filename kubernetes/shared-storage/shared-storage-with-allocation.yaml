---
# Shared Storage with Separate Allocations
# Uses 1.8TB storage split into 1.5TB for /k8s-storage and 1.5TB for /vm-storage

apiVersion: v1
kind: Namespace
metadata:
  name: shared-storage-system
  labels:
    name: shared-storage-system
    purpose: shared-storage-management
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: shared-storage-config
  namespace: shared-storage-system
data:
  storage-info: |
    # Shared Storage Configuration with Separate Allocations
    # Total Storage: 1.8TB per server
    # Split into separate allocations:
    # - /k8s-storage: 1.5TB for Kubernetes workloads
    # - /vm-storage: 1.5TB for VM provisioning
    # - System Reserve: 0.3TB (300GB)
    
    # Directory Structure:
    # /shared-storage/
    # ├── k8s-storage/        # 1.5TB for Kubernetes
    # │   ├── databases/      # Database storage
    # │   ├── applications/   # Application data
    # │   ├── monitoring/     # Monitoring data
    # │   ├── logs/          # Log storage
    # │   └── backups/       # Backup storage
    # ├── vm-storage/         # 1.5TB for VM provisioning
    # │   ├── images/        # VM images
    # │   ├── templates/     # VM templates
    # │   ├── instances/     # VM instances
    # │   ├── snapshots/     # VM snapshots
    # │   └── backups/       # VM backups
    # └── system/            # 300GB system reserve
  storage-allocations: |
    k8s_storage: 1500  # 1.5TB for Kubernetes
    vm_storage: 1500   # 1.5TB for VM provisioning
    system_reserve: 300 # 300GB system reserve
---
apiVersion: batch/v1
kind: Job
metadata:
  name: setup-shared-storage-with-allocation
  namespace: shared-storage-system
spec:
  template:
    spec:
      restartPolicy: OnFailure
      containers:
      - name: setup-storage
        image: alpine:latest
        command:
        - /bin/sh
        - -c
        - |
          # Install required packages
          apk add --no-cache qemu-img
          
          # Create shared storage root directory
          mkdir -p /shared-storage
          
          # Create K8s storage directories (1.5TB allocation)
          mkdir -p /shared-storage/k8s-storage/{databases,applications,monitoring,logs,backups}
          
          # Create VM storage directories (1.5TB allocation)
          mkdir -p /shared-storage/vm-storage/{images,templates,instances,snapshots,backups}
          
          # Create system reserve directory
          mkdir -p /shared-storage/system
          
          # Set permissions
          chmod -R 755 /shared-storage
          
          # Set ownership for K8s storage (user/group 1000)
          chown -R 1000:1000 /shared-storage/k8s-storage
          
          # Set ownership for VM storage (user/group 1001)
          chown -R 1001:1001 /shared-storage/vm-storage
          
          # Set ownership for system directory
          chown -R root:root /shared-storage/system
          
          # Create VM templates
          echo "Creating VM templates..."
          qemu-img create -f qcow2 /shared-storage/vm-storage/templates/ubuntu22.qcow2 20G
          qemu-img create -f qcow2 /shared-storage/vm-storage/templates/centos7.qcow2 20G
          qemu-img create -f qcow2 /shared-storage/vm-storage/templates/rhel8.qcow2 20G
          qemu-img create -f qcow2 /shared-storage/vm-storage/templates/rockylinux9.qcow2 20G
          
          # Create storage configuration
          cat > /shared-storage/storage-config.yaml << 'EOF'
          shared_storage:
            total_size_gb: 1800
            allocations:
              k8s_storage:
                size_gb: 1500
                path: "/shared-storage/k8s-storage"
                owner: "1000:1000"
                subdirectories:
                  - databases
                  - applications
                  - monitoring
                  - logs
                  - backups
              vm_storage:
                size_gb: 1500
                path: "/shared-storage/vm-storage"
                owner: "1001:1001"
                subdirectories:
                  - images
                  - templates
                  - instances
                  - snapshots
                  - backups
              system_reserve:
                size_gb: 300
                path: "/shared-storage/system"
                owner: "root:root"
          EOF
          
          # Create storage monitoring script
          cat > /shared-storage/monitor-storage.sh << 'EOF'
          #!/bin/sh
          echo "=== Shared Storage Usage Report $(date) ==="
          echo ""
          echo "Total Storage:"
          df -h /shared-storage
          echo ""
          echo "K8s Storage Usage (1.5TB allocation):"
          du -sh /shared-storage/k8s-storage/*
          echo ""
          echo "VM Storage Usage (1.5TB allocation):"
          du -sh /shared-storage/vm-storage/*
          echo ""
          echo "System Reserve Usage (300GB allocation):"
          du -sh /shared-storage/system/*
          echo ""
          echo "Storage Health Check:"
          
          # Check K8s storage usage
          k8s_usage=$(du -s /shared-storage/k8s-storage 2>/dev/null | awk '{print $1}')
          k8s_usage_gb=$((k8s_usage / 1024 / 1024))
          k8s_limit_gb=1500
          k8s_percentage=$((k8s_usage_gb * 100 / k8s_limit_gb))
          
          if [ $k8s_percentage -gt 90 ]; then
            echo "CRITICAL: K8s storage is ${k8s_percentage}% full (${k8s_usage_gb}GB / ${k8s_limit_gb}GB)"
          elif [ $k8s_percentage -gt 75 ]; then
            echo "WARNING: K8s storage is ${k8s_percentage}% full (${k8s_usage_gb}GB / ${k8s_limit_gb}GB)"
          else
            echo "OK: K8s storage is ${k8s_percentage}% full (${k8s_usage_gb}GB / ${k8s_limit_gb}GB)"
          fi
          
          # Check VM storage usage
          vm_usage=$(du -s /shared-storage/vm-storage 2>/dev/null | awk '{print $1}')
          vm_usage_gb=$((vm_usage / 1024 / 1024))
          vm_limit_gb=1500
          vm_percentage=$((vm_usage_gb * 100 / vm_limit_gb))
          
          if [ $vm_percentage -gt 90 ]; then
            echo "CRITICAL: VM storage is ${vm_percentage}% full (${vm_usage_gb}GB / ${vm_limit_gb}GB)"
          elif [ $vm_percentage -gt 75 ]; then
            echo "WARNING: VM storage is ${vm_percentage}% full (${vm_usage_gb}GB / ${vm_limit_gb}GB)"
          else
            echo "OK: VM storage is ${vm_percentage}% full (${vm_usage_gb}GB / ${vm_limit_gb}GB)"
          fi
          
          echo "Storage monitoring completed"
          EOF
          
          chmod +x /shared-storage/monitor-storage.sh
          
          echo "Shared storage with separate allocations setup completed"
        volumeMounts:
        - name: shared-storage
          mountPath: /shared-storage
      volumes:
      - name: shared-storage
        hostPath:
          path: /
---
# K8s Storage Local Path Provisioner
apiVersion: v1
kind: ServiceAccount
metadata:
  name: k8s-storage-provisioner-service-account
  namespace: shared-storage-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: k8s-storage-provisioner-role
rules:
- apiGroups: [""]
  resources: ["nodes", "persistentvolumes"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["endpoints"]
  verbs: ["get", "list", "watch", "create", "update", "patch"]
- apiGroups: [""]
  resources: ["persistentvolumeclaims"]
  verbs: ["get", "list", "watch", "update"]
- apiGroups: [""]
  resources: ["persistentvolumes"]
  verbs: ["get", "list", "watch", "create", "delete", "patch"]
- apiGroups: ["storage.k8s.io"]
  resources: ["storageclasses"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create", "update", "patch"]
- apiGroups: ["coordination.k8s.io"]
  resources: ["leases"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: k8s-storage-provisioner-bind
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: k8s-storage-provisioner-role
subjects:
- kind: ServiceAccount
  name: k8s-storage-provisioner-service-account
  namespace: shared-storage-system
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: k8s-storage-provisioner
  namespace: shared-storage-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: k8s-storage-provisioner
  template:
    metadata:
      labels:
        app: k8s-storage-provisioner
    spec:
      serviceAccountName: k8s-storage-provisioner-service-account
      containers:
      - name: k8s-storage-provisioner
        image: rancher/local-path-provisioner:v0.0.24
        imagePullPolicy: IfNotPresent
        command:
        - local-path-provisioner
        - start
        - --config
        - /etc/config/config.json
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: config-volume
          mountPath: /etc/config/
        - name: storage-path
          mountPath: /opt/local-path-provisioner
        - name: shared-storage
          mountPath: /shared-storage
      volumes:
      - name: config-volume
        configMap:
          name: k8s-storage-config
      - name: storage-path
        hostPath:
          path: /opt/local-path-provisioner
      - name: shared-storage
        hostPath:
          path: /
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k8s-storage-config
  namespace: shared-storage-system
data:
  config.json: |
    {
      "nodePathMap":[
      {
        "node": "DEFAULT_PATH_FOR_NON_LISTED_NODES",
        "paths": ["/shared-storage/k8s-storage"]
      }
      ]
    }
---
# K8s Storage Classes
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: k8s-database-storage
provisioner: rancher.io/local-path
reclaimPolicy: Retain
volumeBindingMode: WaitForFirstConsumer
parameters:
  path: "/shared-storage/k8s-storage/databases"
---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: k8s-app-storage
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
provisioner: rancher.io/local-path
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer
parameters:
  path: "/shared-storage/k8s-storage/applications"
---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: k8s-monitoring-storage
provisioner: rancher.io/local-path
reclaimPolicy: Retain
volumeBindingMode: WaitForFirstConsumer
parameters:
  path: "/shared-storage/k8s-storage/monitoring"
---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: k8s-log-storage
provisioner: rancher.io/local-path
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer
parameters:
  path: "/shared-storage/k8s-storage/logs"
---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: k8s-backup-storage
provisioner: rancher.io/local-path
reclaimPolicy: Retain
volumeBindingMode: WaitForFirstConsumer
parameters:
  path: "/shared-storage/k8s-storage/backups"
---
# VM Storage Manager
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: vm-storage-manager
  namespace: shared-storage-system
spec:
  selector:
    matchLabels:
      app: vm-storage-manager
  template:
    metadata:
      labels:
        app: vm-storage-manager
    spec:
      containers:
      - name: vm-storage-manager
        image: alpine:latest
        command:
        - /bin/sh
        - -c
        - |
          # Install required packages
          apk add --no-cache qemu-img bc
          
          # Function to get storage usage
          get_storage_usage() {
            local path="$1"
            if [ -d "$path" ]; then
              du -s "$path" 2>/dev/null | awk '{print $1}' || echo "0"
            else
              echo "0"
            fi
          }
          
          # Function to convert KB to GB
          kb_to_gb() {
            local kb="$1"
            echo "scale=2; $kb / 1024 / 1024" | bc
          }
          
          # Monitor VM storage usage
          while true; do
            echo "=== VM Storage Usage Report $(date) ==="
            
            # Get VM storage usage
            vm_usage_kb=$(get_storage_usage "/shared-storage/vm-storage")
            vm_usage_gb=$(kb_to_gb "$vm_usage_kb")
            
            echo "VM Storage Usage: ${vm_usage_gb}GB / 1500GB"
            
            # Check if approaching limit
            if (( $(echo "$vm_usage_gb > 1350" | bc -l) )); then
              echo "WARNING: VM storage usage is ${vm_usage_gb}GB (limit: 1500GB)"
            fi
            
            # Get individual VM sizes
            echo "Individual VM Sizes:"
            for vm_dir in /shared-storage/vm-storage/instances/*; do
              if [ -d "$vm_dir" ]; then
                vm_id=$(basename "$vm_dir")
                vm_size_kb=$(get_storage_usage "$vm_dir")
                vm_size_gb=$(kb_to_gb "$vm_size_kb")
                echo "  VM $vm_id: ${vm_size_gb}GB"
              fi
            done
            
            # Check VM templates
            echo "VM Templates:"
            ls -la /shared-storage/vm-storage/templates/
            
            echo "VM storage monitoring completed"
            echo "================================="
            sleep 300  # Check every 5 minutes
          done
        volumeMounts:
        - name: shared-storage
          mountPath: /shared-storage
      volumes:
      - name: shared-storage
        hostPath:
          path: /
---
# Storage Monitor
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: storage-monitor
  namespace: shared-storage-system
spec:
  selector:
    matchLabels:
      app: storage-monitor
  template:
    metadata:
      labels:
        app: storage-monitor
    spec:
      containers:
      - name: storage-monitor
        image: alpine:latest
        command:
        - /bin/sh
        - -c
        - |
          while true; do
            echo "=== Shared Storage Monitor $(date) ==="
            
            # Run storage monitoring script
            /shared-storage/monitor-storage.sh
            
            echo "Shared storage monitoring completed"
            echo "=================================="
            sleep 300  # Check every 5 minutes
          done
        volumeMounts:
        - name: shared-storage
          mountPath: /shared-storage
      volumes:
      - name: shared-storage
        hostPath:
          path: /
---
# Storage Cleanup CronJob
apiVersion: batch/v1
kind: CronJob
metadata:
  name: storage-cleanup
  namespace: shared-storage-system
spec:
  schedule: "0 2 * * *"  # Run daily at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: cleanup
            image: alpine:latest
            command:
            - /bin/sh
            - -c
            - |
              echo "Starting shared storage cleanup..."
              
              # Clean up K8s storage
              echo "Cleaning up K8s storage..."
              find /shared-storage/k8s-storage/backups -type f -mtime +30 -delete 2>/dev/null || true
              find /shared-storage/k8s-storage/logs -type f -mtime +7 -delete 2>/dev/null || true
              find /shared-storage/k8s-storage -name "*.tmp" -delete 2>/dev/null || true
              find /shared-storage/k8s-storage -name "*.temp" -delete 2>/dev/null || true
              
              # Clean up VM storage
              echo "Cleaning up VM storage..."
              find /shared-storage/vm-storage/snapshots -type f -mtime +90 -delete 2>/dev/null || true
              find /shared-storage/vm-storage/backups -type f -mtime +30 -delete 2>/dev/null || true
              find /shared-storage/vm-storage/instances -name "*.qcow2" -mtime +7 -exec rm -f {} \; 2>/dev/null || true
              find /shared-storage/vm-storage -name "*.tmp" -delete 2>/dev/null || true
              find /shared-storage/vm-storage -name "*.temp" -delete 2>/dev/null || true
              
              # Optimize VM disk images
              echo "Optimizing VM disk images..."
              for qcow_file in /shared-storage/vm-storage/instances/*/*.qcow2; do
                if [ -f "$qcow_file" ]; then
                  echo "Optimizing: $qcow_file"
                  qemu-img convert -O qcow2 -c "$qcow_file" "${qcow_file}.optimized" 2>/dev/null || true
                  if [ -f "${qcow_file}.optimized" ]; then
                    mv "${qcow_file}.optimized" "$qcow_file"
                  fi
                fi
              done
              
              echo "Shared storage cleanup completed"
            volumeMounts:
            - name: shared-storage
              mountPath: /shared-storage
          volumes:
          - name: shared-storage
            hostPath:
              path: /
          restartPolicy: OnFailure
---
# VM Storage API Service
apiVersion: v1
kind: Service
metadata:
  name: vm-storage-api
  namespace: shared-storage-system
spec:
  selector:
    app: vm-storage-manager
  ports:
  - port: 8080
    targetPort: 8080
    protocol: TCP
  type: ClusterIP